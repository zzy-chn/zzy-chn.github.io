<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>动态规划（线性，区间，树形，数据结构优化，四边形不等式） | zzy-blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">动态规划（线性，区间，树形，数据结构优化，四边形不等式）</h1><a id="logo" href="/.">zzy-blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">动态规划（线性，区间，树形，数据结构优化，四边形不等式）</h1><div class="post-meta">2019-08-01<span> | </span><span class="category"><a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-To-The-Max%EF%BC%8CHDU1081"><span class="toc-number">1.</span> <span class="toc-text">A - To The Max，HDU1081</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-BUY-LOW-BUY-LOWER%EF%BC%8CPOJ1952"><span class="toc-number">2.</span> <span class="toc-text">B - BUY LOW, BUY LOWER，POJ1952</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Monkey-and-Banana%EF%BC%8CHDU1069"><span class="toc-number">3.</span> <span class="toc-text">C - Monkey and Banana，HDU1069</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-Trip%EF%BC%8CPOJ1934"><span class="toc-number">4.</span> <span class="toc-text">D - Trip，POJ1934</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-Polygon%EF%BC%8CPOJ1179"><span class="toc-number">5.</span> <span class="toc-text">E - Polygon，POJ1179</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-Palindrome-subsequence%EF%BC%8CHDU4632"><span class="toc-number">6.</span> <span class="toc-text">F - Palindrome subsequence，HDU4632</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-You-Are-the-One%EF%BC%8CHDU4283"><span class="toc-number">7.</span> <span class="toc-text">G - You Are the One，HDU4283</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-Anniversary-party%EF%BC%8CPOJ2342"><span class="toc-number">8.</span> <span class="toc-text">H - Anniversary party，POJ2342</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-Accumulation-Degree%EF%BC%8CPOJ3585"><span class="toc-number">9.</span> <span class="toc-text">I - Accumulation Degree，POJ3585</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-Computer%EF%BC%8CHDU2196"><span class="toc-number">10.</span> <span class="toc-text">J - Computer，HDU2196</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Tree-Painting%EF%BC%8CCodeForces1187E"><span class="toc-number">11.</span> <span class="toc-text">K - Tree Painting，CodeForces1187E</span></a></li></ol></div></div><div class="post-content"><h3 id="A-To-The-Max，HDU1081"><a href="#A-To-The-Max，HDU1081" class="headerlink" title="A - To The Max，HDU1081"></a>A - To The Max，HDU1081</h3><p>求最大子矩阵和，把二维转换到一维，把每一行的某些列的和看作一个元素，这样就成了一维下的最大子段和，预处理每行的前缀和，暴力枚举每行的的列数情况即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N][N], dp[N][N], n, res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        res = <span class="number">0</span>, <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) cin &gt;&gt; c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dp[i][j] = dp[i][j - <span class="number">1</span>] + c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                    sum += dp[k][j] - dp[k][i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-BUY-LOW-BUY-LOWER，POJ1952"><a href="#B-BUY-LOW-BUY-LOWER，POJ1952" class="headerlink" title="B - BUY LOW, BUY LOWER，POJ1952"></a>B - BUY LOW, BUY LOWER，POJ1952</h3><p>最长下降子序列很简单就能求出，但是还要额外求一个方案数</p>
<p>设$dp[i]$为以$i$结尾的最长下降子序列的长度，$num[i]$为以$i$结尾的最长下降子序列的个数</p>
<p>所以状态转移方程为$dp[i] &#x3D; max(dp[i], dp[j] + 1)(c[j]&gt;c[i])$，$num[i] +&#x3D; num[j](c[j]&gt;c[i]\ and\ dp[j]+1&#x3D;&#x3D;dp[i])$</p>
<p>但这样求出来的$num$是没有去重的，考虑到$c[j]&#x3D;&#x3D;c[i]\ and\ dp[j]&#x3D;&#x3D;dp[i]$时，$c[i]$可以完全被$c[j]$替代，此时$num[i]$应该等于$0$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c[N], dp[N], num[N], imax, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[j] &gt; c[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == dp[i]) num[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[j] &gt; c[i] &amp;&amp; dp[j] + <span class="number">1</span> == dp[i]) num[i] += num[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c[j] == c[i] &amp;&amp; dp[j] == dp[i]) num[i] = <span class="number">0</span>; <span class="comment">// 能够被c[j]代替，所以num[i]=0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) imax = <span class="built_in">max</span>(imax, dp[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (imax == dp[i]) ans += num[i];</span><br><span class="line">    cout &lt;&lt; imax &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-Monkey-and-Banana，HDU1069"><a href="#C-Monkey-and-Banana，HDU1069" class="headerlink" title="C - Monkey and Banana，HDU1069"></a>C - Monkey and Banana，HDU1069</h3><p>矩阵嵌套的变形，每个立方体有六个面，每个面都能作为底面，预处理一下，就跟矩阵嵌套一样了，排个序后动态规划</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node c[N];</span><br><span class="line"><span class="type">int</span> dp[N], n, cnt, imax, icas;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> node one, <span class="type">const</span> node two)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (one.x != two.x) <span class="keyword">return</span> one.x &lt; two.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> one.y &lt; two.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; <span class="number">0</span> != n) &#123;</span><br><span class="line">        imax = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tp_x, tp_y, tp_z;</span><br><span class="line">            cin &gt;&gt; tp_x &gt;&gt; tp_y &gt;&gt; tp_z;</span><br><span class="line">            c[++cnt].x = tp_x, c[cnt].y = tp_y, c[cnt].z = tp_z;</span><br><span class="line">            c[++cnt].x = tp_y, c[cnt].y = tp_x, c[cnt].z = tp_z;</span><br><span class="line">            c[++cnt].x = tp_y, c[cnt].y = tp_z, c[cnt].z = tp_x;</span><br><span class="line">            c[++cnt].x = tp_z, c[cnt].y = tp_y, c[cnt].z = tp_x;</span><br><span class="line">            c[++cnt].x = tp_x, c[cnt].y = tp_z, c[cnt].z = tp_y;</span><br><span class="line">            c[++cnt].x = tp_z, c[cnt].y = tp_x, c[cnt].z = tp_y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(c + <span class="number">1</span>, c + cnt + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) dp[i] = c[i].z;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[i].x &gt; c[j].x &amp;&amp; c[i].y &gt; c[j].y) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + c[i].z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) imax = <span class="built_in">max</span>(imax, dp[i]);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++icas &lt;&lt; <span class="string">&quot;: maximum height = &quot;</span> &lt;&lt; imax &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-Trip，POJ1934"><a href="#D-Trip，POJ1934" class="headerlink" title="D - Trip，POJ1934"></a>D - Trip，POJ1934</h3><p>最长公共子序列问题（LCS），当$a[i]&#x3D;&#x3D;b[j]$时，$dp[i][j]&#x3D;d[i-1][j-1]+1$，当$a[i]!&#x3D;b[j]$时，$dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1])$</p>
<p>但是最坑的是需要输出方案数，一开始想的是暴搜，但肯定会超时</p>
<p>但仔细想一想，其实有很多的搜索是不必要的，比如两个串的某两个位置的字符不相等，这样就没必要继续向前一位搜索了，我们就可以直接跳到当前位置前有公共字符的位置继续搜索</p>
<p>所以预处理$l\_a[N][26]$和$l\_b[N][26]$数组，分别表示$a$字符串和$b$字符串在第$i$位前面第$j$个字母第一次出现的位置</p>
<p>如果$a$字符串和$b$字符串当前位置的字符相等，则可以向前递归，即跳到$pos\_a-1$和$pos\_b-1$进行递归</p>
<p>如果$a$字符串和$b$字符串当前位置的字符不相等，则没有必要向前递归，直接跳到当前位置前面第$i$个字符相等的位置，即跳到$l\_a[pos\_a][i]-1$和$l\_b[pos\_b][i]-1$进行递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> dp[N][N], l_a[N][M], l_b[N][M];</span><br><span class="line"><span class="type">int</span> len_a, len_b;</span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos_a, <span class="type">int</span> pos_b, <span class="type">int</span> len, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == len) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pos_a || <span class="number">0</span> == pos_b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[pos_a] == b[pos_b]) <span class="built_in">dfs</span>(pos_a - <span class="number">1</span>, pos_b - <span class="number">1</span>, len - <span class="number">1</span>, s + a[pos_a]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">                <span class="type">int</span> tp_one = l_a[pos_a][i], tp_two = l_b[pos_b][i];</span><br><span class="line">                <span class="keyword">if</span> (len == dp[tp_one][tp_two]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(tp_one - <span class="number">1</span>, tp_two - <span class="number">1</span>, len - <span class="number">1</span>, s + <span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    len_a = <span class="built_in">strlen</span>(a + <span class="number">1</span>), len_b = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span> + j)) l_a[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span> l_a[i][j] = l_a[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[i] == <span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span> + j)) l_b[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span> l_b[i][j] = l_b[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len_b; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(len_a, len_b, dp[len_a][len_b], <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)res.<span class="built_in">size</span>(); i++) cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-Polygon，POJ1179"><a href="#E-Polygon，POJ1179" class="headerlink" title="E - Polygon，POJ1179"></a>E - Polygon，POJ1179</h3><p>感觉像一个加强版的成环石子合并，先来回顾一下成环的石子合并</p>
<p>将原序列复制一份放在后面，枚举起点$i$，用区间合并去计算区间$[i,i+n]$这个区间的最大值</p>
<p>这题就是把区间合并中对两个区间的操作换了下，石子合并是两个区间值相加，这题两个区间值能够相加，相乘，而且区间值可能为负，这就导致我们要记录一个最大值一个最小值</p>
<p>当两个区间值相乘时：</p>
<ul>
<li>两个大的正区间值相乘得到一个更大的正区间值，即$imax[l][r] &#x3D; max(imax[l][r], imax[l][k - 1] * imax[k][r])$</li>
<li>两个小的负区间值相乘得到一个大的正区间值，即$imax[l][r] &#x3D; max(imax[l][r], imin[l][k - 1] * imin[k][r])$</li>
<li>两个小的正区间值相乘得到一个小的正区间值，即$imin[l][r] &#x3D; min(imin[l][r], imin[l][k - 1] * imax[k][r])$</li>
<li>一个正区间值和一个负区间值相乘得到一个负区间值，即$imin[l][r] &#x3D; min(imin[l][r], imin[l][k - 1] * imin[k][r])$</li>
<li>一个负区间值和一个正区间值相乘得到一个负区间值，即$imin[l][r] &#x3D; min(imin[l][r], imax[l][k - 1] * imin[k][r])$</li>
</ul>
<p>当两个区间相加时：</p>
<ul>
<li>两个大的正区间值相加得到一个更大的正区间值，即$imax[l][r] &#x3D; max(imax[l][r], imax[l][k - 1] + imax[k][r])$</li>
<li>两个小的负区间值相加得到一个更小的负区间值，即$imin[l][r] &#x3D; min(imin[l][r], imin[l][k - 1] + imin[k][r])$</li>
</ul>
<p>所以只需要把对两个区间的操作换成以上七种就跟石子合并是一样的了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> imax[N][N], imin[N][N];</span><br><span class="line"><span class="type">int</span> a[N], op[N], pos[N];</span><br><span class="line"><span class="type">int</span> n, tot, ans = -INF;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(imax, -INF, <span class="built_in">sizeof</span>(imax));</span><br><span class="line">    <span class="built_in">memset</span>(imin, INF, <span class="built_in">sizeof</span>(imin));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= x + n - <span class="number">1</span>; i++) imin[i][i] = imax[i][i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = x; l &lt;= x + n - len; l++) &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l + <span class="number">1</span>; k &lt;= r; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == op[k]) &#123;</span><br><span class="line">                    imax[l][r] = <span class="built_in">max</span>(imax[l][r], imax[l][k - <span class="number">1</span>] * imax[k][r]);</span><br><span class="line">                    imax[l][r] = <span class="built_in">max</span>(imax[l][r], imin[l][k - <span class="number">1</span>] * imin[k][r]);</span><br><span class="line">                    imin[l][r] = <span class="built_in">min</span>(imin[l][r], imin[l][k - <span class="number">1</span>] * imax[k][r]);</span><br><span class="line">                    imin[l][r] = <span class="built_in">min</span>(imin[l][r], imin[l][k - <span class="number">1</span>] * imin[k][r]);</span><br><span class="line">                    imin[l][r] = <span class="built_in">min</span>(imin[l][r], imax[l][k - <span class="number">1</span>] * imin[k][r]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    imax[l][r] = <span class="built_in">max</span>(imax[l][r], imax[l][k - <span class="number">1</span>] + imax[k][r]);</span><br><span class="line">                    imin[l][r] = <span class="built_in">min</span>(imin[l][r], imin[l][k - <span class="number">1</span>] + imin[k][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imax[x][x + n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; ch &gt;&gt; a[i]; a[i + n] = a[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> == ch) op[i] = op[i + n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> op[i] = op[i + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tp = <span class="built_in">cal</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (tp == ans) pos[++tot] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; tp) ans = tp, pos[tot = <span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == tot) cout &lt;&lt; pos[i] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; pos[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F-Palindrome-subsequence，HDU4632"><a href="#F-Palindrome-subsequence，HDU4632" class="headerlink" title="F - Palindrome subsequence，HDU4632"></a>F - Palindrome subsequence，HDU4632</h3><p>求一个字符串的回文子序列的数目</p>
<p>设$dp[i][j]$为字符串$s$中从$i$到$j$的回文子序列的数目</p>
<p>$dp[i][j]$有$dp[i+1][j]$和$dp[i][j-1]$转移过来，但考虑到有重叠部分$i+1$到$j-1$，所以$dp[i][j] &#x3D; (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + MOD) % MOD$</p>
<p>当$s[i]&#x3D;&#x3D;s[j]$时，$s[i]$和$s[j]$与$s[i+1]$到$s[j-1]$内的回文子序列都能构成一个新的回文序列，两者本身也构成回文子序列，即$dp[i][j] &#x3D; (dp[i][j] + dp[i + 1][j - 1] + 1 + MOD) % MOD$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> dp[N][N], t, len, icas;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= len; d++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + d &lt;= len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + d;</span><br><span class="line">                dp[i][j] = (dp[i + <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + MOD) % MOD;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) dp[i][j] = (dp[i][j] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++icas, dp[<span class="number">1</span>][len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-You-Are-the-One，HDU4283"><a href="#G-You-Are-the-One，HDU4283" class="headerlink" title="G - You Are the One，HDU4283"></a>G - You Are the One，HDU4283</h3><p>设$dp[l][r]$表示在不考虑其他人的情况下第$l$个人到第$r$个人产生的不开心值总和，预处理一个数组$sum[i]$表示前$i$个人的屌丝值总和</p>
<p>枚举$l$到$r$的分割点$k$，两种情况：</p>
<ul>
<li>第$l$到第$k-1$个人上台后第$k$到第$r$个人才上台，这样第$k$到第$r$个人会不但会产生在不考虑其他人的情况下$dp[k][r]$的不开心值，还会产生在等待第$l$到第$k-1$个人上台表演过程中产生的不开心值$(sum[r] - sum[k - 1]) * (k - l)$，而第$l$到第$k-1$个人只会产生不考虑其他人的情况下产生的不开心值$dp[l][k-1]$，最后有$dp[l][r]&#x3D;dp[l][k - 1] + dp[k][r] + (sum[r] - sum[k - 1]) * (k - l)$</li>
<li>第$k$到第$r$个人上台后第$l$到第$k-1$的个人才上台，这样第$k$到第$r$个人只会产生不考虑其他人的情况下产生的不开心值$dp[k][r]$，而第$l$到第$k-1$个人会不但会产生在不考虑其他人的情况下$dp[l][k-1]$的不开心值，还会产生在等待第$k$到第$r$个人上台表演过程中产生的不开心值$(sum[k-1] - sum[l-1]) * (r-k+1)$，又因为栈是先进后出的，所以这种情况下第$l$个人第一个进栈，就会最后一个出栈，第$l$到第$k-1$在等待的过程中又会额外增加不高兴值，预处理一个数组$buf[i][j]$表示这种情况下第$i$到第$j$个人额外增加的不开心值，最后有$dp[l][r]&#x3D;dp[l][k - 1] + dp[k][r] + (sum[k - 1] - sum[l - 1]) * (r - k + 1) + buf[l][k - 1]$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, icas;</span><br><span class="line"><span class="type">int</span> dp[N][N], d[N], sum[N], buf[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_buf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            buf[i][j] = buf[i + <span class="number">1</span>][j] + (j - i) * d[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; d[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + d[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) dp[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get_buf</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++) &#123;</span><br><span class="line">                <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = l + <span class="number">1</span>; k &lt;= r; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> tp_one = dp[l][k - <span class="number">1</span>] + dp[k][r] + (sum[r] - sum[k - <span class="number">1</span>]) * (k - l); <span class="comment">// 前面的人先进</span></span><br><span class="line">                    <span class="type">int</span> tp_two = dp[l][k - <span class="number">1</span>] + dp[k][r] + (sum[k - <span class="number">1</span>] - sum[l - <span class="number">1</span>]) * (r - k + <span class="number">1</span>) + buf[l][k - <span class="number">1</span>];</span><br><span class="line">                    dp[l][r] = <span class="built_in">min</span>(dp[l][r], <span class="built_in">min</span>(tp_one, tp_two));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++icas &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="H-Anniversary-party，POJ2342"><a href="#H-Anniversary-party，POJ2342" class="headerlink" title="H - Anniversary party，POJ2342"></a>H - Anniversary party，POJ2342</h3><p>设$dp[u][0]$表示选择$u$节点时子树欢乐值的最大值，$dp[u][1]$表示不选择$u$节点时子树快乐值的最大值</p>
<p>设$v$是$u$的子节点，两种情况：</p>
<ul>
<li>不选择父节点$u$时，其所有的子节点$v$可以选也可以不选，即$dp[u][0] +&#x3D; max(dp[v][0], dp[v][1])$</li>
<li>选择父节点$u$时，其所有的子节点都不能选，即$dp[u][1] +&#x3D; dp[v][0]$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nex[N];</span><br><span class="line"><span class="type">int</span> dp[N][M], in[N];</span><br><span class="line"><span class="type">int</span> val[N], vis[N];</span><br><span class="line"><span class="type">int</span> n, a, b, res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>, dp[u][<span class="number">0</span>] = <span class="number">0</span>, dp[u][<span class="number">1</span>] = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nex[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = nex[u][i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; <span class="number">0</span> != n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nex[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; val[i];</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &amp;&amp; <span class="number">0</span> != (a + b)) nex[b].<span class="built_in">push_back</span>(a), in[a]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == in[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i); res = <span class="built_in">max</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-Accumulation-Degree，POJ3585"><a href="#I-Accumulation-Degree，POJ3585" class="headerlink" title="I - Accumulation Degree，POJ3585"></a>I - Accumulation Degree，POJ3585</h3><p>换根的板子都差不多，用链式前向星存图，关键是公式如何推导</p>
<p>设$dp[u]$表示第一次深搜得出每个节点最大的流量，$res[u]$表示以$u$为根节点时该结点最大的流量</p>
<p>第二次深搜，对于每一个子节点$v$有两种情况：</p>
<ul>
<li>当这个节点的父节点$u$的度为$1$时，节点$u$只有一个子节点$v$，此时状态转移方程$res[v] &#x3D; dp[v] + edge[i].val$</li>
<li>当这个节点的父节点$u$的度不为$1$时，节点$u$不止一个子节点$v$，所以先要求出除$v$节点以外所以$u$节点的子节点的流量和$res[u] - min(dp[v], edge[i].val)$，画图后，得出状态转移方程$res[v] &#x3D; dp[v] + min(edge[i].val, res[u] - min(dp[v], edge[i].val))$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nex, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node edge[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> dp[N], res[N], vis[N], head[N], deg[N];</span><br><span class="line"><span class="type">int</span> t, n, a, b, c, cnt, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in">sizeof</span>(res));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="built_in">sizeof</span>(deg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].val = w;</span><br><span class="line">    edge[cnt].nex = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp_max</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; <span class="number">0</span> != i; i = edge[i].nex) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp_max</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == deg[v]) dp[u] += edge[i].val;</span><br><span class="line">        <span class="keyword">else</span> dp[u] += <span class="built_in">min</span>(dp[v], edge[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; <span class="number">0</span> != i; i = edge[i].nex) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == deg[u]) res[v] = dp[v] + edge[i].val;</span><br><span class="line">        <span class="keyword">else</span> res[v] = dp[v] + <span class="built_in">min</span>(edge[i].val, res[u] - <span class="built_in">min</span>(dp[v], edge[i].val));</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            <span class="built_in">add_edge</span>(a, b, c), <span class="built_in">add_edge</span>(b, a, c);</span><br><span class="line">            deg[a] += <span class="number">1</span>, deg[b] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">dp_max</span>(<span class="number">1</span>);</span><br><span class="line">        res[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, res[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="J-Computer，HDU2196"><a href="#J-Computer，HDU2196" class="headerlink" title="J - Computer，HDU2196"></a>J - Computer，HDU2196</h3><p>换根的题，不过不能只记录一个根节点到叶子节点的最大值，还要记录一个根节点到到叶子节点的第二大的值，顺便记录一下每个节点的最大值是从哪个子节点转移过来的</p>
<p>设$maxn[i]$和$smaxn[i]$分别表示$i$节点到叶子节点的最大值和第二大的值，$m\_id[i]$和$sm\_id[i]$分别表示$i$节点的最大值和第二大的值从哪个节点转移过来</p>
<p>当从父节点$u$向子节点$v$转移的时候，有两种情况：</p>
<ul>
<li>如果父节点$u$的最大值是从子节点$v$转移过来的，那么就需要判断$smaxn[u] + edge[i].val$和$smaxn[v]$的大小关系，如果前者比后者大，则更新$smaxn[v]$和$sm\_id[v]$后再判断$smaxn[v]$和$maxn[v]$的大小关系</li>
<li>如果父节点$u$的最大值不是从子节点$v$转移过来的，那么就需要判断$maxn[u] + edge[i].val$和$smaxn[v]$的大小关系，如果前者比后者大，则更新$smaxn[v]$和$sm\_id[v]$后再判断$smaxn[v]$和$maxn[v]$的大小关系</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nex, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a, w;</span><br><span class="line">node edge[N];</span><br><span class="line"><span class="type">int</span> head[N], cnt;</span><br><span class="line"><span class="type">int</span> smaxn[N], maxn[N];</span><br><span class="line"><span class="type">int</span> sm_id[N], m_id[N];</span><br><span class="line"><span class="comment">//sm_id[i]=j表示i节点从j节点转移过来</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].val = w;</span><br><span class="line">    edge[cnt].nex = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    smaxn[u] = maxn[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; <span class="number">0</span> != i; i = edge[i].nex) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(v, u);</span><br><span class="line">        <span class="keyword">if</span> (maxn[v] + edge[i].val &gt; smaxn[u]) &#123;</span><br><span class="line">            smaxn[u] = maxn[v] + edge[i].val;</span><br><span class="line">            sm_id[u] = v;</span><br><span class="line">            <span class="keyword">if</span> (smaxn[u] &gt; maxn[u]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(smaxn[u], maxn[u]);</span><br><span class="line">                <span class="built_in">swap</span>(sm_id[u], m_id[u]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; <span class="number">0</span> != i; i = edge[i].nex) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (v == m_id[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smaxn[u] + edge[i].val &gt; smaxn[v]) &#123;</span><br><span class="line">                smaxn[v] = smaxn[u] + edge[i].val;</span><br><span class="line">                sm_id[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (smaxn[v] &gt; maxn[v]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(smaxn[v], maxn[v]);</span><br><span class="line">                    <span class="built_in">swap</span>(sm_id[v], m_id[v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxn[u] + edge[i].val &gt; smaxn[v]) &#123;</span><br><span class="line">                smaxn[v] = maxn[u] + edge[i].val;</span><br><span class="line">                sm_id[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (smaxn[v] &gt; maxn[v]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(smaxn[v], maxn[v]);</span><br><span class="line">                    <span class="built_in">swap</span>(sm_id[v], m_id[v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>; <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;w);</span><br><span class="line">            <span class="built_in">add_edge</span>(i, a, w), <span class="built_in">add_edge</span>(a, i, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="K-Tree-Painting，CodeForces1187E"><a href="#K-Tree-Painting，CodeForces1187E" class="headerlink" title="K - Tree Painting，CodeForces1187E"></a>K - Tree Painting，CodeForces1187E</h3><p>设$sum[i]$表示第一次深搜后第$i$个节点子树的节点数量，设$res[i]$表示以$i$为根节点时答案</p>
<p>假设第一次从节点$1$开始深搜，则有$res[1]&#x3D;n+dp[2]+dp[3]+…+dp[n]$</p>
<p>当从$1$转移到它的子节点$2$时有$res[2]&#x3D;n+dp[3]+…+dp[n]+dp[1]-dp[2]$</p>
<p>则有$res[1]&#x3D;res[2]+dp[1]-2*dp[2]$，推广得$res[v]&#x3D;res[u]+dp[1]-2*dp[v]$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node edge[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N], res[N], ans;</span><br><span class="line"><span class="type">int</span> vis[N], head[N];</span><br><span class="line"><span class="type">int</span> n, a, b, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].nex = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp_max</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u] = <span class="number">1</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; <span class="number">0</span> != i; i = edge[i].nex) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp_max</span>(v);</span><br><span class="line">        dp[u] += dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; <span class="number">0</span> != i; i = edge[i].nex) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        res[v] = res[u] + dp[<span class="number">1</span>] - <span class="number">2</span> * dp[v];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add_edge</span>(a, b), <span class="built_in">add_edge</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp_max</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res[<span class="number">1</span>] += dp[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, res[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/10/19/The%202019%20ICPC%20China%20Nanchang%20National%20Invitational%20and%20International%20Silk-Road%20Programming%20Contest%20-%20F.Sequence(%E6%89%93%E8%A1%A8+%E7%BA%BF%E6%AE%B5%E6%A0%91)/">The 2019 ICPC China Nanchang National Invitational and International Silk-Road Programming Contest - F.Sequence(打表+线段树)</a><a class="next" href="/2019/07/23/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6&amp;%E6%A6%82%E7%8E%87&amp;%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/">组合数学&amp;概率&amp;数学期望</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpg"/></a><p>日拱一卒 功不唐捐</p><a class="info-icon" href="mailto:1747849084@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zzy-chn" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Codeforces/">Codeforces</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/29/Codeforces%20Round%20698%20(Div.%202)/">Codeforces Round 698 (Div. 2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/17/Codeforces%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/">Codeforces训练记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/15/2017%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E6%9D%AD%E5%B7%9E%E7%AB%99%20-%20B.%20Master%20of%20Phi(%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0)/">2017中国大学生程序设计竞赛-杭州站 - B. Master of Phi(积性函数)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/02/Codeforces%20Round%20636%20(Div.%203)/">Codeforces Round 636 (Div. 3)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/%E8%87%AA%E9%80%82%E5%BA%94Simpson%E7%A7%AF%E5%88%86/">自适应Simpson积分</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B9%9D%E5%9C%BA%EF%BC%89-%20E.%20Groundhog%20Chasing%20Death/">2020牛客暑期多校训练营（第九场）- E. Groundhog Chasing Death</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/2020%20Multi-University%20Training%20Contest%206%20-%201007.%20A%20Very%20Easy%20Math%20Problem(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/">2020 Multi-University Training Contest 6 - 1007. A Very Easy Math Problem(莫比乌斯反演)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/31/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">拉格朗日插值法学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">二次剩余学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/2020%20Multi-University%20Training%20Contest%203%20-%201008.%20Triangle%20Collision(%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95+%E4%BA%8C%E5%88%86)/">2020 Multi-University Training Contest 3 - 1008. Triangle Collision(计算几何+二分)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">zzy-blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>